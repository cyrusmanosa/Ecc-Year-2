// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: accompany.sql

package db

import (
	"context"

)

const createAccompany = `-- name: CreateAccompany :one
INSERT INTO accompany (
    user_id,
    era,
    speaklanguage,
    find_type,
    sociability
) VALUES (
    $1,$2,$3,$4,$5
) RETURNING user_id, era, speaklanguage, find_type, sociability, info_changed_at
`

type CreateAccompanyParams struct {
	UserID        int32       `json:"user_id"`
	Era           int32 `json:"era"`
	Speaklanguage []string    `json:"speaklanguage"`
	FindType      string `json:"find_type"`
	Sociability   string `json:"sociability"`
}

func (q *Queries) CreateAccompany(ctx context.Context, arg CreateAccompanyParams) (Accompany, error) {
	row := q.db.QueryRow(ctx, createAccompany,
		arg.UserID,
		arg.Era,
		arg.Speaklanguage,
		arg.FindType,
		arg.Sociability,
	)
	var i Accompany
	err := row.Scan(
		&i.UserID,
		&i.Era,
		&i.Speaklanguage,
		&i.FindType,
		&i.Sociability,
		&i.InfoChangedAt,
	)
	return i, err
}

const deleteAccompany = `-- name: DeleteAccompany :exec
DELETE FROM accompany 
WHERE user_id = $1
`

func (q *Queries) DeleteAccompany(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteAccompany, userID)
	return err
}

const getAccompany = `-- name: GetAccompany :one
SELECT user_id, era, speaklanguage, find_type, sociability, info_changed_at FROM accompany
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetAccompany(ctx context.Context, userID int32) (Accompany, error) {
	row := q.db.QueryRow(ctx, getAccompany, userID)
	var i Accompany
	err := row.Scan(
		&i.UserID,
		&i.Era,
		&i.Speaklanguage,
		&i.FindType,
		&i.Sociability,
		&i.InfoChangedAt,
	)
	return i, err
}

const listAccompany = `-- name: ListAccompany :many
SELECT user_id, era, speaklanguage, find_type, sociability, info_changed_at FROM accompany
ORDER BY user_id
`

func (q *Queries) ListAccompany(ctx context.Context) ([]Accompany, error) {
	rows, err := q.db.Query(ctx, listAccompany)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Accompany{}
	for rows.Next() {
		var i Accompany
		if err := rows.Scan(
			&i.UserID,
			&i.Era,
			&i.Speaklanguage,
			&i.FindType,
			&i.Sociability,
			&i.InfoChangedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccompany = `-- name: UpdateAccompany :one
UPDATE accompany
SET era = $2,
    speaklanguage= $3,
    find_type= $4,
    sociability= $5
WHERE user_id = $1
RETURNING user_id, era, speaklanguage, find_type, sociability, info_changed_at
`

type UpdateAccompanyParams struct {
	UserID        int32       `json:"user_id"`
	Era           int32 `json:"era"`
	Speaklanguage []string    `json:"speaklanguage"`
	FindType      string `json:"find_type"`
	Sociability   string `json:"sociability"`
}

func (q *Queries) UpdateAccompany(ctx context.Context, arg UpdateAccompanyParams) (Accompany, error) {
	row := q.db.QueryRow(ctx, updateAccompany,
		arg.UserID,
		arg.Era,
		arg.Speaklanguage,
		arg.FindType,
		arg.Sociability,
	)
	var i Accompany
	err := row.Scan(
		&i.UserID,
		&i.Era,
		&i.Speaklanguage,
		&i.FindType,
		&i.Sociability,
		&i.InfoChangedAt,
	)
	return i, err
}
